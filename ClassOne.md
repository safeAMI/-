 最近，我在看《算法图解》时，终于明白了一个困扰我很久的问题: 对于背包问题，当物品的数量为1件而且你对dp数组进行了一个维度的压缩时 ，遍历的顺序必须是从后往前的。

     看例子:

    你有一个背包可以装下4磅的物品，你面对的选择:<0(吉他),1磅,1500美元>,<1(音响),4磅,3000美元>,<2(笔记本电脑),3磅,2000美元>(物品序号,value,weight)。

     状态转移方程，很简单dp[i][j]=max(dp[i-1][j],dp[i-1][ j-weight[i] ]+value[i])。对于这个状态转移方程，你填充的是二维矩阵，一行一行地填，从前还是从后遍历都没有影响,因为你填下一行矩阵时，总是看的上一行。

     状态压缩,dp[j]=max(dp[j],dp[ j-weight[i] ]+value[i])。对于这个状态转移方程，你填充的是一维矩阵，从前遍历，看的是上一格。比如说填二磅时，你再次面对吉他，你就是去找前面一个，dp[2-1],同样是吉他。但是吉他只有一个，所以就不对了。而你从后往前遍历，因为是减号(-weight[i]),你看的是前面的，是旧的，更新了的在后面。

     进阶例题：[一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)。

     关于这个例题，两点注意：

      1.它把字符串当物品，‘0’和‘1’当重量，value都是1

      2.因为它的重量有两个限制，需要二维，所以不压缩是三维。
